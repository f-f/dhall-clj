(ns dhall-clojure.in.parse
  (:require [instaparse.core :as insta]
            [clojure.java.io :as io]
            [dhall-clojure.in.core :refer :all]
            [dhall-clojure.in.import :as imp]
            [dhall-clojure.in.fail :as fail]
            [clojure.string :as str]))

(def grammar
  "The Dhall grammar specified in ABNF"
  (slurp (io/resource "dhall.abnf")))

(def dhall-parser
  "Dhall parser generated by Instaparse from the ABNF grammar"
  (insta/parser grammar
                :input-format :abnf
                :start :complete-expression
                :output-format :enlive))

(defn- clean
  "Cut the names of the attrs of the tree
  TODO: save the meta!"
  [tree]
  (if (map? tree)
    {:c (mapv clean (:content tree))
     ;;:a (:attrs tree)
     :t (:tag tree)}
    tree))

(defn parse
  "Parses the Dhall input, on success returns an Enlive-style tree.
  Throws on a failed parse."
  [dhall-string]
  (let [parsed (dhall-parser dhall-string)]
    (if (insta/failure? parsed)
      (fail/parsing! parsed)
      (clean parsed))))

;;
;; Utils
;;
(declare expr)

(defn first-child-expr
  "Folds the current expression into its first child"
  [e]
  (expr (-> e :c first)))

(defn children?
  "True if there is more than one child"
  [e]
  (> (count (:c e)) 1))

(defn compact
  "Given a parse tree, it will compact all the text in it,
  and return a single string"
  [tree]
  (cond
    (map? tree) (apply str (mapv compact (:c tree)))
    (string? tree) tree
    (seqable? tree) (apply str (mapv compact tree))
    :else tree))

;;
;; Parse Tree -> Expression Tree
;;

(defmulti expr
  "Takes an enlive parse tree, and constructs a tree of
  objects implementing IExpr"
  :t)


;;
;; Rules that we eliminate as not needed
;;

(defmethod expr :complete-expression [e]
  (expr (-> e :c second)))

(defmethod expr :operator-expression [e]
  (first-child-expr e))

(defmethod expr :import-expression [e]
  (first-child-expr e))


;;
;; Import rules
;;

(defmethod expr :import [{:keys [c]}]
  (let [import (expr (first c))
        mode (if (> (count c) 1) ;; If yes, we have a "as Text"
               ;; FIXME: other imports modes go here, maybe make it more robust
               :text
               :code)]
    (assoc import :mode mode)))

(defmethod expr :import-hashed [{:keys [c]}]
  (let [import (expr (first c))
        hash?  (when (> (count c) 1) ;; If yes, we have a hash
                 (expr (second c)))]
    (assoc import :hash? hash?)))

(defmethod expr :hash [{:keys [c]}]
  (-> c
     (compact)
     (subs 7) ;; Cut the "sha256:" prefix here
     (str/trim)))

(defmethod expr :import-type [{:keys [c]}]
  (-> c first expr))

(defmethod expr :env [{:keys [c]}]
  (let [envname (compact (nth c (if (string? (second c)) 2 1)))
        env (imp/->Env envname)]
    (imp/map->Import {:type :env
                      :data env})))

(defmethod expr :local [{:keys [c]}]
  (let [raw-c (-> c first :c)
        relative? (string? (first raw-c))
        prefix (when relative?
                 (first raw-c))
        compact-path-component #(-> % :c rest compact)
        directory (->> (nth raw-c (if relative? 1 0))
                     :c
                     (map compact-path-component))
        file (-> raw-c
                (nth (if relative? 2 1))
                :c first
                compact-path-component)
        local (imp/->Local prefix directory file)]
    (imp/map->Import {:type :local
                      :data local})))

(defmethod expr :http [{:keys [c]}]
  {:a c})

;;
;; Useful rules that parse the pure subset of the language
;;

(defmethod expr :expression [{:keys [c t]}]
  (let [first-tag (-> c first :t)]
    (case first-tag
      :lambda (->Lam (expr (nth c 2))
                     (expr (nth c 4))
                     (expr (nth c 7)))
      :if     (->BoolIf (expr (nth c 1))
                        (expr (nth c 3))
                        (expr (nth c 5)))
      :let    (if (> (count c) 6)
                (->Let (expr (nth c 1))
                       (expr (nth c 3))
                       (expr (nth c 5))
                       (expr (nth c 7)))
                (->Let (expr (nth c 1))
                       nil
                       (expr (nth c 3))
                       (expr (nth c 5))))
      :forall (->Pi (expr (nth c 2))
                    (expr (nth c 4))
                    (expr (nth c 7)))
      :operator-expression  (->Pi "_"
                                  (expr (nth c 0))
                                  (expr (nth c 2)))
      :annotated-expression (-> c first expr))))

(defmethod expr :annotated-expression [{:keys [c t]}]
  (let [first-tag (-> c first :t)]
    (case first-tag
      :merge               (->Merge
                             (-> c (nth 1)     expr)
                             (-> c (nth 2)     expr)
                             (if (>= (count c) 5)
                               (-> c (nth 4) expr)
                               nil))
      :open-bracket        (-> c second expr)
      :operator-expression (if (> (count c) 1)
                             (->Annot
                               (expr (nth c 0))
                               (expr (nth c 2)))
                             (expr (first c))))))

(defmethod expr :empty-collection [{:keys [c t]}]
  (let [typ       (-> c last expr)]
    (if (= :List (-> c (nth 2) :t))
      (->ListLit     typ [])
      (->OptionalLit typ nil))))

(defmethod expr :non-empty-optional [{:keys [c t]}]
  (let [typ   (-> c last  expr)
        value (-> c first expr)]
    (->OptionalLit typ value)))

(defmethod expr :reserved-raw [e]
  (let [first-tag (-> e :c first :t)]
    (case first-tag
      :Bool-raw     (->BoolT)
      :Optional-raw (->OptionalT)
      :Natural-raw  (->NaturalT)
      :Integer-raw  (->IntegerT)
      :Double-raw   (->DoubleT)
      :Text-raw     (->TextT)
      :List-raw     (->ListT)
      :True-raw     (->BoolLit true)
      :False-raw    (->BoolLit false)
      :Type-raw     (->Const :type)
      :Kind-raw     (->Const :kind)
      :missing-raw  (imp/->Import :missing nil :code (imp/->Missing)))))

(defmethod expr :reserved-namespaced-raw [e]
  (let [first-tag (-> e :c first :t)]
    (case first-tag
      :Natural-fold-raw      (->NaturalFold)
      :Natural-build-raw     (->NaturalBuild)
      :Natural-isZero-raw    (->NaturalIsZero)
      :Natural-even-raw      (->NaturalEven)
      :Natural-odd-raw       (->NaturalOdd)
      :Natural-toInteger-raw (->NaturalToInteger)
      :Natural-show-raw      (->NaturalShow)
      :Integer-toDouble-raw  (->IntegerToDouble)
      :Integer-show-raw      (->IntegerShow)
      :Double-show-raw       (->DoubleShow)
      :List-build-raw        (->ListBuild)
      :List-fold-raw         (->ListFold)
      :List-length-raw       (->ListLength)
      :List-head-raw         (->ListHead)
      :List-last-raw         (->ListLast)
      :List-indexed-raw      (->ListIndexed)
      :List-reverse-raw      (->ListReverse)
      :Optional-fold-raw     (->OptionalFold)
      :Optional-build-raw    (->OptionalBuild))))

(defn identifier [e]
  (let [children (:c e)
        ;; if we have  a simple identifier, the "prefix" is just the label
        ;; if instead it's a prefixed identifier, the prefix is the reserved word
        prefix (if (= :identifier (:t e))
                 (->> children first expr)
                 (->> children first :c first :c (apply str)))
        ;; at the end of `children` there might be a DeBrujin index
        maybe-index (-> children butlast last)
        index? (= :natural-raw (:t maybe-index))
        index (if index?
                (-> maybe-index :c first :c first read-string)
                0)
        ;; the label is the rest of the chars
        ;; if it's an identifier without prefix this is going to
        ;; be an empty string, so all good
        label (->> children
                 rest
                 (drop-last (if index? 3 1))
                 compact)]
    (->Var (str prefix label) index)))

(defmethod expr :identifier [e]
  (identifier e))

(defmethod expr :identifier-reserved-namespaced-prefix [e]
  (identifier e))

(defmethod expr :identifier-reserved-prefix [e]
  (identifier e))

(defmacro defexpr*
  "Generalize `defmethod` for the cases in which we need to do
  something like:
  - if there's one remove this tag
  - if there's multiple create an `Expr a b` and recur with left-precedence"
  [parser-tag record-class separator-tag]
  (let [expr-constructor (symbol (str "->" record-class))]
    `(defmethod expr ~parser-tag [e#]
       (if (> (count (:c e#)) 1)
         (let [exprs# (remove #(or (= ~separator-tag (:t %))
                                   (= :whitespace-chunk (:t %)))
                              (:c e#))]
           (loop [more# (nnext exprs#)
                  start# (~expr-constructor
                           (expr (first exprs#))
                           (expr (second exprs#)))]
             (if (empty? more#)
               start#
               (recur (rest more#)
                      (~expr-constructor start# (expr (first more#)))))))
         (expr (-> e# :c first))))))


(defexpr* :import-alt-expression    ImportAlt    :import-alt)
(defexpr* :or-expression            BoolOr       :or)
(defexpr* :plus-expression          NaturalPlus  :plus)
(defexpr* :text-append-expression   TextAppend   :text-append)
(defexpr* :list-append-expression   ListAppend   :list-append)
(defexpr* :and-expression           BoolAnd      :and)
(defexpr* :combine-expression       Combine      :combine)
(defexpr* :prefer-expression        Prefer       :prefer)
(defexpr* :combine-types-expression CombineTypes :combine-types)
(defexpr* :times-expression         NaturalTimes :times)
(defexpr* :equal-expression         BoolEQ       :double-equal)
(defexpr* :not-equal-expression     BoolNE       :not-equal)

(defmethod expr :application-expression [{:keys [c t]}]
  (if (> (count c) 1)
    (let [exprs (remove #(= :whitespace-chunk (:t %)) c)
          constructors? (= :constructors (-> c first :t))]
      (loop [more (nnext exprs)
             app (if constructors?
                   (->Constructors (expr (second exprs)))
                   (->App
                     (expr (first exprs))
                     (expr (second exprs))))]
        (if (empty? more)
          app
          (recur (rest more)
                 (->App app (expr (first more)))))))
    (expr (-> c first))))

(defmethod expr :selector-expression [e]
  (if (children? e)
    (let [exprs (remove #(= :dot (:t %)) (:c e))
          base  (expr (first exprs))
          labels? (fn [l] (= :labels (:t l)))]
      (loop [more (nnext exprs)
             sel ((if (labels? (second exprs))
                    ->Project
                    ->Field)
                  base
                  (expr (second exprs)))]
        (if (empty? more)
          sel
          (recur (rest more)
                 ((if (labels? (first more))
                    ->Project
                    ->Field)
                  sel
                  (expr (first more)))))))
    (-> e :c first expr))) ;; Otherwise we go to the primitive expression

(defmethod expr :labels [{:keys [c t]}]
  (->> c
     rest
     (take-nth 2)
     (mapv expr)))

(defmethod expr :primitive-expression [e]
  (let [first-tag (-> e :c first :t)
        children (:c e)]
    (case first-tag
      :double-literal  (-> children first compact read-string ->DoubleLit)
      :natural-literal (-> children first compact read-string ->NaturalLit)
      :integer-literal (-> children first compact read-string ->IntegerLit)
      :text-literal                          (-> children first expr)
      :open-brace                            (-> children second expr)
      :open-angle                            (-> children second expr)
      :non-empty-list-literal                (-> children first expr)
      :identifier-reserved-namespaced-prefix (-> children first expr)
      :reserved-namespaced                   (-> children first :c first expr)
      :identifier-reserved-prefix            (-> children first expr)
      :reserved                              (-> children first :c first expr)
      :identifier                            (-> children first expr)
      :open-parens                           (-> children second expr))))

(defmethod expr :union-type-or-literal [e]
  (let [first-tag (-> e :c first :t)]
    (case first-tag
      :non-empty-union-type-or-literal
      (let [[k v kvs] (->> e :c first expr)]
        (if (and k v) ;; if we actually have a value, we have a Union Literal
          (->UnionLit k v kvs)
          (->UnionT kvs)))
      (->UnionT {})))) ;; Empty union type

;; This should return a vector `[k v kvs]`,
;; where `k` is the value key, `v` is its value,
;; and `kvs` are the remaining types.
;; `k` and `v` can be `nil`, and that means it's a Union type
(defmethod expr :non-empty-union-type-or-literal [e]
  (let [children (:c e)
        label    (-> children first expr)
        literal? (= :equal (-> children second :t))
        value    (-> children (nth 2) expr)
        more?    (> (count children) 3)]
    (if literal?
      ;; If we got our key:value here, we just
      ;; merge into the kvs the remaining type
      [label value (if more?
                     (->> (-> e :c (nthrest 3))
                        (partition 4)
                        (mapv (fn [[bar label colon expr']]
                                {(expr label)
                                 (expr expr')}))
                        (apply merge))
                     {})]
      ;; Otherwise our label:value is another type declaration,
      ;; and we recur into the next types (if any), merging the
      ;; current label:value into the next kvs
      (if more?
        (let [[k v kvs] (-> children (nth 4) expr)]
          [k v (merge kvs {label value})])
        [nil nil {label value}]))))

(defmethod expr :record-type-or-literal [e]
  (let [first-tag (-> e :c first :t)]
    (case first-tag
      :equal                            (->RecordLit {}) ;; Empty record literal
      :non-empty-record-type-or-literal (-> e :c first expr)
      (->RecordT {}))))                                  ;; Empty record type

(defmethod expr :non-empty-record-type-or-literal [e]
  (let [first-label (-> e :c first expr)
        other-vals (-> e :c second)
        record-literal? (= (:t other-vals) :non-empty-record-literal)
        [first-val other-kvs] [(-> other-vals :c second expr)
                               (->> (-> other-vals :c (nthrest 2))
                                  (partition 4)
                                  (mapv (fn [[comma label sep expr']]
                                          {(expr label)
                                           (expr expr')}))
                                  (apply merge))]]
    ((if record-literal?
       ->RecordLit
       ->RecordT)
     (merge {first-label first-val} other-kvs))))

(defmethod expr :label [e]
  (let [quoted? (-> e :c first string?) ;; a quoted label is preceded by `
        actual-label ((if quoted? second first) (:c e))
        str-label (->> actual-label :c
                      (mapv (fn [ch]
                              (if (string? ch)
                                ch
                                (-> ch :c first))))
                      (apply str))]
    (if quoted?
      (str "`" str-label "`")
      str-label)))

(defmethod expr :non-empty-list-literal [e]
  ;; Here we always pass the type as nil, because it's a non empty list,
  ;; and the eventual type annotation has this wrapped in an Annot
  (let [vals (->> e :c rest (take-nth 2) (mapv expr))]
    (->ListLit nil vals)))

(defmethod expr :text-literal [e]
  (let [first-tag (-> e :c first :t)
        children (:c e)]
    (->TextLit
      (if (= first-tag :double-quote-literal)
        ;; If it's a double quoted string, we fold on the children,
        ;; so that we collapse the contiguous strings in a single chunk,
        ;; while skipping the interpolation expressions
        (loop [children (-> children first :c rest butlast) ;; Skip the quotes
               acc nil
               chunks []]
          (if (seq children)
            (let [chunk (first children)
                  content (:c chunk)]
              (if (every? string? content)  ;; If they are not strings, it's an interpolation
                (recur (rest children)
                       (str acc (apply str content))
                       chunks)
                (recur (rest children)
                       nil
                       (conj chunks acc (expr (nth content 1))))))
            ;; If we have no children left to process,
            ;; we return the chunks we have, plus the accomulator
            (if-not acc
              chunks
              (conj chunks acc))))
        ;; Otherwise it's a single quote literal,
        ;; so we recur over the children until we find an ending literal.
        ;; As above, we make expressions out of interpolation syntax
        (loop [children (-> children first :c second :c)
               acc nil
               chunks []]
          (if (= children ["''"])
            (if-not acc  ;; If we have chars left in acc
              chunks
              (conj chunks acc))
            (if (not= (first children) "${")  ;; Check if interpolation
              ;; If not we just add the string and recur
              (recur (-> children second :c)
                     (str acc (first children))
                     chunks)
              (recur (-> children (nth 3) :c)
                     nil
                     (conj chunks acc (expr (second children)))))))))))

;; Default case, we end up here when there is no matches
(defmethod expr :default [e]
  (fail/ast-building! e))
